"""

Strategy objects take market data as input and produce trading signal events as output
A Strategy object encapsulates all calculations on market data that generate advisory signals to a Portfolio object.
At this stage in the event-driven backtester development there is no concept of an indicator or filter, such as those
found in technical trading. These are also good candidates for creating a class hierarchy but are beyond the scope of this article.
The strategy hierarchy is relatively simple as it consists of an abstract base class with a single pure virtual method for generating SignalEvent objects

"""

import datetime
import numpy as np
import pandas as pd
import queue

from abc import ABCMeta, abstractmethod

from event import SignalEvent


class Strategy(object):
	"""
	Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
	"""

	__metaclass__ = ABCMeta
	@abstractmethod
	def caculate_signals(self):
		"""
		Provides the mechanisms to calculate the list of signals.
		"""
		raise NotImplementedError("Should implement calculate_signals()")

class BuyAndHoldStrategy(Strategy):
	"""
	This is an extremely simple strategy that goes LONG all of the
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
	"""
	def __init__(self, bars, events):
		"""
		:param bars: The DataHandler object that provides bar information
		:param events: The Event Queue object.
		"""
		self.bars = bars
		self.events = events
		self.symbol_list = self.bars.symbol_list

		# Once buy & hold signal is given, these are set to True
		self.bought = {s:False for s in self.symbol_list} # self._calculate_initial_bought()

	def _calculate_initial_bought(self):
		"""
		Adds keys to the bought dictionary for all symbols
        and sets them to False.
		:return: dictionary where keys are symbols, values are True if to buy
		"""
		bought = {s:False for s in self.symbol_list}
		return bought


	def caculate_signals(self, event):
		"""
		For "Buy and Hold" we generate a single signal per symbol and then
		no additional signals. This is implemented by constantly adding long signal
		to the market in the queue data-structure since the date of strategy initialisation

		:param event: A MarketEvent object.
		:return:
		"""
		if event.type == 'MARKET':
			for s in self.symbol_list:
				bars = self.bars.get_latest_bars(s, N=1)
				if bars is not None and bars != []:
					if self.bought[s] == False:
						# (Symbol, Datetime, Type = LONG, SHORT or EXIT)
						signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
						self.events.put(signal)
						self.bought[s] = False
